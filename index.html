<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title>Interactive 3D Device Model</title>
	<style>
		body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0e4666; color: #eef; }
		#info {
			position: absolute; top: 10px; left: 10px; padding: 10px 15px;
			background: rgba(0, 20, 35, 0.35); border: 1px solid rgba(255,255,255,0.25);
			border-radius: 8px; max-width: 320px; backdrop-filter: blur(6px);
		}
		#info h1 { font-size: 1.1em; margin: 0 0 6px 0; }
		#info p { font-size: 0.9em; margin: 0; }
		#loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 1.1em; }
		canvas { display: block; }
	</style>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
	<div id="info">
		<h1>Custom Device Assembly</h1>
		<p>Drag to rotate, scroll to zoom, right-click to pan.</p>
	</div>
	<div id="loader">Loading 3D Scene...</div>

	<script type="importmap">
	{
		"imports": {
			"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
			"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
		}
	}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		// --- SCENE-WIDE VARS ---
		let scene, camera, renderer, controls, fanGroup, fan2Group; // fanGroup is now accessible globally
		let device, reefGroup, netMesh, waterSphere, particles, bubblePoints;
		const loaderElement = document.getElementById('loader');
		const mm = 0.001; // 1 mm = 0.001 units
		const clock = new THREE.Clock();

		function init() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0a3d62);
			scene.fog = new THREE.Fog(0x0e4666, 5, 40);

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(2.6, 2.0, 3.4);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild(renderer.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.minDistance = 1;
			controls.maxDistance = 25;

			// Underwater lighting
			const hemi = new THREE.HemisphereLight(0x6bb9f0, 0x0b2b3c, 1.15);
			scene.add(hemi);

			const dir = new THREE.DirectionalLight(0xffffff, 1.8);
			dir.position.set(5, 10, 7.5);
			dir.castShadow = true;
			dir.shadow.mapSize.set(2048, 2048);
			dir.shadow.camera.near = 0.5;
			dir.shadow.camera.far = 50;
			scene.add(dir);

			// Seafloor with slight undulations
			const groundGeo = new THREE.PlaneGeometry(40, 40, 64, 64);
			for (let i = 0; i < groundGeo.attributes.position.count; i++) {
				const x = groundGeo.attributes.position.getX(i);
				const z = groundGeo.attributes.position.getZ(i);
				const wobble = (Math.sin(x * 0.6) + Math.cos(z * 0.5)) * 0.02;
				groundGeo.attributes.position.setY(i, wobble);
			}
			groundGeo.computeVertexNormals();
			const groundMat = new THREE.MeshStandardMaterial({ color: 0xc8b693, roughness: 0.95 });
			const ground = new THREE.Mesh(groundGeo, groundMat);
			ground.rotation.x = -Math.PI / 2;
			ground.receiveShadow = true;
			scene.add(ground);

			// Water volume (inside a big translucent sphere)
			waterSphere = createWaterVolume();
			scene.add(waterSphere);

			// Materials
			const marineAluminiumMaterial = new THREE.MeshStandardMaterial({
				color: 0xD9D9D6, metalness: 0.4, roughness: 0.9, envMapIntensity: 0.8
			});
			const titaniumMaterial = new THREE.MeshStandardMaterial({
				color: 0xaaaaaa, metalness: 0.4, roughness: 0.15, envMapIntensity: 0.9
			});
			const insulatedWireMaterial = new THREE.MeshStandardMaterial({
				color: 0x111111, roughness: 0.8, metalness: 0.1
			});

			// DEVICE (we'll elevate it above the mesh)
			device = new THREE.Group();
			device.add(createHexFrame(marineAluminiumMaterial));
			device.add(createSolarArray(marineAluminiumMaterial));
			device.add(createCamera());
			device.add(createUnderwaterAntenna(marineAluminiumMaterial));
			const m1 = createExhaustMotor(600, 150, 190, fanGroup);
			fanGroup = m1.fangrp;
			device.add(m1.motorGroup);
			const m2 = createExhaustMotor(600, 150, -190, fan2Group);
			fan2Group = m2.fangrp;
			device.add(m2.motorGroup);

			device.add(createElectrodeSystem(titaniumMaterial, insulatedWireMaterial, marineAluminiumMaterial));

			// REEF directly beneath the device, covered by a mesh/net
			reefGroup = createCoralReef();                 // y ~ 0 (sits on seafloor)
			netMesh   = createReefNet(1.05, 0.75);         // radius, domeHeight
			netMesh.position.y = 0.0;                      // base at seafloor; dome rises to ~0.75

			// Place the device ABOVE the mesh (clear separation)
			device.position.set(0, 1.10, 0);               // bottom of device (~0.0) lifted to ~1.10
			controls.target.set(0, 1.0, 0);                // orbit focus at device height

			// Group them nicely
			const site = new THREE.Group();
			site.add(reefGroup);
			site.add(netMesh);
			site.add(device);
			scene.add(site);

			// Water particles (moving current) + bubbles near motor to imply motion
			particles    = createWaterParticles(1500, 18); // count, radius
			bubblePoints = createBubbles(new THREE.Vector3(-0.65, 1.10, 0.0), 120); // origin near motor, count
			scene.add(particles, bubblePoints);

			loaderElement.style.display = 'none';
			animate();
		}

		// --- WATER VOLUME ---
		function createWaterVolume() {
			const waterGeo = new THREE.SphereGeometry(60, 64, 64);
			const waterMat = new THREE.MeshPhysicalMaterial({
				color: 0x1e90ff,
				transmission: 0.88,
				transparent: true,
				opacity: 1.0,
				thickness: 5,
				roughness: 0.35,
				metalness: 0.0,
				side: THREE.BackSide
			});
			return new THREE.Mesh(waterGeo, waterMat);
		}

		// --- CORAL REEF (beneath) ---
		function createCoralReef() {
			const group = new THREE.Group();

			// Base rock
			const rock = new THREE.Mesh(
				new THREE.DodecahedronGeometry(0.6, 0),
				new THREE.MeshStandardMaterial({ color: 0x675c4a, roughness: 1 })
			);
			rock.scale.set(1.8, 0.6, 1.4);
			rock.position.y = 0.05;
			rock.castShadow = true; rock.receiveShadow = true;
			group.add(rock);

			const palette = [0xff6f61, 0xffa552, 0xffc0cb, 0x8e7cc3, 0x46c2b1, 0xf39c12];
			const rng = (a, b) => a + Math.random() * (b - a);

			function tubeCoral(radius = 0.06, height = 0.35, color = 0xff6f61) {
				const m = new THREE.Mesh(
					new THREE.CylinderGeometry(radius, radius * 0.8, height, 16, 1, false),
					new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.05 })
				);
				m.castShadow = true; m.receiveShadow = true;
				return m;
			}
			function boulderCoral(r = 0.18, color = 0xffc0cb) {
				const m = new THREE.Mesh(
					new THREE.IcosahedronGeometry(r, 1),
					new THREE.MeshStandardMaterial({ color, roughness: 0.8, metalness: 0.0 })
				);
				m.castShadow = true; m.receiveShadow = true;
				return m;
			}
			function branchingCoral(r = 0.05, color = 0x8e7cc3) {
				const m = new THREE.Mesh(
					new THREE.TorusKnotGeometry(r, r * 0.35, 80, 8, 2, 3),
					new THREE.MeshStandardMaterial({ color, roughness: 0.55, metalness: 0.05 })
				);
				m.castShadow = true; m.receiveShadow = true;
				return m;
			}

			for (let i = 0; i < 10; i++) {
				const c = tubeCoral(rng(0.04, 0.08), rng(0.25, 0.45), palette[i % palette.length]);
				c.position.set(rng(-0.6, 0.6), 0.18, rng(-0.5, 0.5));
				c.rotation.z = rng(-0.3, 0.3);
				group.add(c);
			}
			for (let i = 0; i < 7; i++) {
				const c = boulderCoral(rng(0.12, 0.24), palette[(i + 3) % palette.length]);
				c.position.set(rng(-0.7, 0.7), 0.12, rng(-0.6, 0.6));
				group.add(c);
			}
			for (let i = 0; i < 4; i++) {
				const c = branchingCoral(rng(0.045, 0.065), palette[(i + 5) % palette.length]);
				c.position.set(rng(-0.5, 0.5), 0.22, rng(-0.4, 0.4));
				c.scale.set(rng(2.2, 3.0), rng(2.2, 3.0), rng(2.2, 3.0));
				group.add(c);
			}
			return group;
		}

		// --- NET COVER over the reef (dome that sits BELOW device) ---
		function createReefNet(radius = 1.05, domeHeight = 0.75) {
			const geo = new THREE.SphereGeometry(radius, 26, 18, 0, Math.PI * 2, 0, Math.asin(domeHeight / radius));
			const wireGeo = new THREE.WireframeGeometry(geo);
			const net = new THREE.LineSegments(
				wireGeo,
				new THREE.LineBasicMaterial({ color: 0x094a63, transparent: true, opacity: 0.7 })
			);
			net.position.y = 0; // base on the seafloor
			return net;
		}

		// --- DEVICE PARTS (original builders) ---
		function createHexFrame(material) {
			const frameGroup = new THREE.Group();
			const diameter = 1500 * mm;
			const height = 750 * mm;
			const thickness = 15 * mm;
			const radius = diameter / 2;

			const domeMesh = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, height, 6), material);
			domeMesh.position.y = height / 2;
			domeMesh.castShadow = true;
			domeMesh.receiveShadow = true;

			const topPlateMesh = new THREE.Mesh(
				new THREE.CylinderGeometry(1200 * mm / 2, 1200 * mm / 2, thickness, 6),
				material
			);
			topPlateMesh.position.y = height;
			topPlateMesh.castShadow = true;

			frameGroup.add(domeMesh, topPlateMesh);
			return frameGroup;
		}

		function createSolarArray(frameMaterial) {
			const arrayGroup = new THREE.Group();
			const panelWidth = 700 * mm;
			const panelHeight = 700 * mm;
			const panelDepth = 25 * mm;
			const mountRingRadius = 1300 * mm / 2;
			const mountHeight = 950 * mm;

			const ring = new THREE.Mesh(new THREE.TorusGeometry(mountRingRadius, 15 * mm, 16, 64), frameMaterial);
			ring.rotation.x = Math.PI / 2;
		            ring.position.y = mountHeight - 170 * mm;
			arrayGroup.add(ring);

			const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x1F3B73, roughness: 0.4 });
			const panelGeometry = new THREE.BoxGeometry(panelWidth, panelHeight, panelDepth);

			[{ x: 0, z: 300 * mm }, { x: 0, z: -300 * mm }].forEach(p => {
				const panelHolder = new THREE.Group();
				panelHolder.position.set(p.x, mountHeight, p.z);
				panelHolder.lookAt(0, mountHeight, 0);

				const panel = new THREE.Mesh(panelGeometry, panelMaterial);
				panel.rotation.x = THREE.MathUtils.degToRad(45);
				panel.castShadow = true;

				panelHolder.add(panel);
				arrayGroup.add(panelHolder);
			});
			return arrayGroup;
		}

		function createCamera() {
			const cameraGroup = new THREE.Group();
			const bodySize = 300 * mm;
			const body = new THREE.Mesh(
				new THREE.BoxGeometry(bodySize, bodySize, bodySize),
				new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4 })
			);
			const lens = new THREE.Mesh(
				new THREE.CylinderGeometry(bodySize * 0.4, bodySize * 0.4, bodySize * 0.2, 32),
				new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.2 })
			);
			lens.rotation.z = Math.PI / 2;
			lens.position.x = bodySize / 2;

			cameraGroup.add(body, lens);
			cameraGroup.position.set(625 * mm, 400 * mm, 0);
			cameraGroup.castShadow = true;
			return cameraGroup;
		}

		function createUnderwaterAntenna(material) {
			const antennaGroup = new THREE.Group();
			const housingHeight = 300 * mm;
			const housingRadius = 100 * mm;

			const housing = new THREE.Mesh(new THREE.CylinderGeometry(housingRadius, housingRadius, housingHeight, 32), material);
			housing.castShadow = true;

			const face = new THREE.Mesh(
				new THREE.CylinderGeometry(housingRadius * 0.9, housingRadius * 0.9, 20 * mm, 32),
				new THREE.MeshStandardMaterial({ color: 0x222228, roughness: 0.8 })
			);
			face.position.y = -housingHeight / 2;
			face.castShadow = true;

			const plate = new THREE.Mesh(
				new THREE.BoxGeometry(housingRadius * 1.5, 25 * mm, housingRadius * 1.5),
				material
			);
			plate.position.y = -housingHeight / 2 - (25 * mm) / 2;

			antennaGroup.add(housing, face, plate);
			antennaGroup.position.set(-650 * mm, 750 * mm + housingHeight / 2, 450 * mm);
			return antennaGroup;
		}

		function createExhaustMotor(x, y, z, fangrp) {
			const motorGroup = new THREE.Group();
			const motorDiameter = 220 * mm;
			const motorDepth = 150 * mm;

			const housing = new THREE.Mesh(
				new THREE.CylinderGeometry(motorDiameter / 2, motorDiameter / 2, motorDepth, 32),
				new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.5 })
			);
			housing.rotation.z = Math.PI / 2;

			// Propeller
			fangrp = new THREE.Group();
			const propellerMaterial = new THREE.MeshStandardMaterial({ color: 0xdaa520, metalness: 0.85, roughness: 0.3, side: THREE.DoubleSide });

			const hubRadius = motorDiameter * 0.12;
			const hub = new THREE.Mesh(new THREE.CylinderGeometry(hubRadius, hubRadius, 40 * mm, 20), propellerMaterial);
			hub.rotation.z = Math.PI / 2;
			fangrp.add(hub);

			const bladeLength = motorDiameter * 0.5;
			const bladeBaseWidth = motorDiameter * 0.1;
			const bladeTipWidth = motorDiameter * 0.2;

			const bladeShape = new THREE.Shape();
			bladeShape.moveTo(-bladeBaseWidth / 2, 0);
			bladeShape.lineTo(-bladeTipWidth / 2, bladeLength);
			bladeShape.quadraticCurveTo(0, bladeLength * 1.05, bladeTipWidth / 2, bladeLength);
			bladeShape.lineTo(bladeBaseWidth / 2, 0);
			bladeShape.quadraticCurveTo(0, -bladeBaseWidth * 0.1, -bladeBaseWidth / 2, 0);

			const bladeGeometry = new THREE.ExtrudeGeometry(bladeShape, { depth: 4 * mm, bevelEnabled: true, bevelThickness: 1 * mm, bevelSize: 1 * mm, bevelSegments: 2 });
			bladeGeometry.translate(0, hubRadius, 0);

			const numBlades = 4;
			for (let i = 0; i < numBlades; i++) {
				const blade = new THREE.Mesh(bladeGeometry, propellerMaterial);
				blade.rotation.order = 'YXZ';
				const angle = (i / numBlades) * Math.PI * 2;
				blade.rotation.y = 0;
				blade.rotation.x = angle;
				fangrp.add(blade);
			}

			motorGroup.add(housing, fangrp);
			motorGroup.castShadow = true;
			motorGroup.position.set(-x * mm, y * mm, z * mm);
			fangrp.position.x = -motorDepth * 0.5 - 30 * mm;
			return { motorGroup, fangrp };
		}

		function createElectrodeSystem(anodeMat, wireMat, cathodeMat) {
			const electrodeGroup = new THREE.Group();

			const anode = new THREE.Mesh(new THREE.CylinderGeometry(100 * mm / 2, 100 * mm / 2, 300 * mm, 128), anodeMat);
			anode.position.y = -(120 * mm / 2);
			anode.castShadow = true;
			electrodeGroup.add(anode);

			const cathodeMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2 });
			const cathodeGroup = new THREE.Group();

			const cathodeBlock = new THREE.Mesh(new THREE.CylinderGeometry(50 * mm / 2, 50 * mm / 2, 150 * mm, 32), cathodeMaterial);
			cathodeBlock.castShadow = true;

			const wireLength = 400 * mm;
			const wireRadius = 16 * mm / 2;
			const startPoint = new THREE.Vector3(300 * mm, 0, 0);
			const endPoint = new THREE.Vector3(300 * mm, -wireLength, 0);

			const curve = new THREE.CatmullRomCurve3([
				startPoint,
				new THREE.Vector3(300 * mm, -wireLength * 0.2, 50 * mm),
				new THREE.Vector3(280 * mm, -wireLength * 0.8, -20 * mm),
				endPoint
			]);

			const wire = new THREE.Mesh(new THREE.TubeGeometry(curve, 20, wireRadius, 8, false), wireMat);
			wire.castShadow = true;

			cathodeBlock.position.copy(endPoint);
			cathodeBlock.position.y -= (80 * mm / 2);

			cathodeGroup.add(wire, cathodeBlock);
			electrodeGroup.add(cathodeGroup);
			return electrodeGroup;
		}

		// --- WATER CURRENT: drifting particles ---
		function createWaterParticles(count = 1000, radius = 15) {
			const geom = new THREE.BufferGeometry();
			const positions = new Float32Array(count * 3);
			for (let i = 0; i < count; i++) {
				const r = Math.random() * radius;
				const theta = Math.random() * Math.PI * 2;
				const phi = Math.acos(2 * Math.random() - 1);
				positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
				positions[i*3+1] = r * Math.cos(phi) * 0.6 + 0.5; // bias upward
				positions[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
			}
			geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
			const mat = new THREE.PointsMaterial({ size: 0.03, transparent: true, opacity: 0.25 });
			return new THREE.Points(geom, mat);
		}

		// --- BUBBLES near motor, rising up ---
		function createBubbles(origin, count = 100) {
			const geom = new THREE.BufferGeometry();
			const positions = new Float32Array(count * 3);
			const speeds = new Float32Array(count);
			for (let i = 0; i < count; i++) {
				positions[i*3+0] = origin.x + (Math.random() - 0.5) * 0.15;
				positions[i*3+1] = origin.y + (Math.random() - 0.5) * 0.10;
				positions[i*3+2] = origin.z + (Math.random() - 0.5) * 0.15;
				speeds[i] = 0.15 + Math.random() * 0.25;
			}
			geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
			geom.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
			const mat = new THREE.PointsMaterial({ size: 0.035, transparent: true, opacity: 0.5 });
			const pts = new THREE.Points(geom, mat);
			pts.userData.origin = origin.clone();
			return pts;
		}

		// --- ANIMATION LOOP ---
		function animate() {
			requestAnimationFrame(animate);
			const t = clock.getElapsedTime();

			// Propeller spin (already suggests motion)
			if (fanGroup) fanGroup.rotation.x += 0.12;
			if (fan2Group) fan2Group.rotation.x += 0.12

			// Gentle bobbing + slight yaw to suggest swimming/drifting
			if (device) {
				device.position.y = 1.10 + Math.sin(t * 0.8) * 0.05; // bob
				device.rotation.y = Math.sin(t * 0.35) * 0.03;       // slow yaw
				device.position.x = Math.sin(t * 0.18) * 0.06;       // subtle lateral drift
			}

			// Very slow "current" rotation on water volume
			if (waterSphere) waterSphere.rotation.y = t * 0.01;

			// Drift the general water particles
			if (particles) {
				const pos = particles.geometry.attributes.position;
				for (let i = 0; i < pos.count; i++) {
					let y = pos.getY(i) + 0.005;        // gentle rise
					let x = pos.getX(i) + Math.sin(t*0.1 + i)*0.0009;
					let z = pos.getZ(i) + Math.cos(t*0.12 + i)*0.0009;
					// wrap particles softly
					if (y > 6) y = -2 + Math.random() * 2;
					pos.setXYZ(i, x, y, z);
				}
				pos.needsUpdate = true;
			}

			// Bubbles from motor rising and resetting near origin
			if (bubblePoints) {
				const pos = bubblePoints.geometry.attributes.position;
				const spd = bubblePoints.geometry.attributes.speed;
				const o = bubblePoints.userData.origin;
				for (let i = 0; i < pos.count; i++) {
					let x = pos.getX(i);
					let y = pos.getY(i) + spd.getX(i) * 0.01;
					let z = pos.getZ(i);
					x += Math.sin(t * 2 + i) * 0.0009;
					z += Math.cos(t * 2 + i) * 0.0009;
					if (y > 2.2) { // reset
						x = o.x + (Math.random() - 0.5) * 0.15;
						y = o.y + (Math.random() - 0.5) * 0.1;
						z = o.z + (Math.random() - 0.5) * 0.15;
					}
					pos.setXYZ(i, x, y, z);
				}
				pos.needsUpdate = true;
			}

			controls.update();
			renderer.render(scene, camera);
		}

		// --- EVENTS ---
		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});

		init();
	</script>
</body>
</html>
